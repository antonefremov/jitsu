package handlers

import (
	"github.com/gin-gonic/gin"
	"github.com/jitsucom/jitsu/configurator/destinations"
	"github.com/jitsucom/jitsu/configurator/entities"
	"github.com/jitsucom/jitsu/configurator/random"
	"github.com/jitsucom/jitsu/configurator/storages"
	enadapters "github.com/jitsucom/jitsu/server/adapters"
	"github.com/jitsucom/jitsu/server/middleware"
	enstorages "github.com/jitsucom/jitsu/server/storages"
	"gopkg.in/yaml.v3"
	"net/http"
)

const configHeaderText = `Generated by https://app.jitsu.com
Documentation: https://docs.eventnative.org

If executed out of our docker container and batch destinations are used, set up events logging
log:
  path: <path to event logs directory>
`

type ConfigHandler struct {
	configurationsService *storages.ConfigurationsService
	defaultS3             *enadapters.S3Config
}

func NewConfigurationHandler(configurationsProvider *storages.ConfigurationsService, s3 *enadapters.S3Config) *ConfigHandler {
	return &ConfigHandler{configurationsService: configurationsProvider, defaultS3: s3}
}

type Server struct {
	Name    *yaml.Node         `json:"name" yaml:"name,omitempty"`
	ApiKeys []*entities.ApiKey `json:"auth" yaml:"auth,omitempty"`
}

type Config struct {
	Server       Server                                   `json:"server" yaml:"server,omitempty"`
	Destinations map[string]*enstorages.DestinationConfig `json:"destinations" yaml:"destinations,omitempty"`
}

func (ch *ConfigHandler) Handler(c *gin.Context) {
	projectId := c.Query("project_id")
	if projectId == "" {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Message: "[project_id] query parameter absents"})
		return
	}
	if !hasAccessToProject(c, projectId) {
		c.JSON(http.StatusUnauthorized, middleware.ErrorResponse{Message: "You are not authorized to request data for project " + projectId})
		return
	}

	keys, err := ch.configurationsService.GetApiKeysByProjectId(projectId)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to get API keys"})
		return
	}

	projectDestinations, err := ch.configurationsService.GetDestinationsByProjectId(projectId)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to get Destinations"})
		return
	}
	mappedDestinations := make(map[string]*enstorages.DestinationConfig)
	for _, destination := range projectDestinations {
		id := destination.Id
		config, err := destinations.MapConfig(id, destination, ch.defaultS3)

		if err != nil {
			c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to build destinations response"})
			return
		}
		mappedDestinations[id] = config
	}

	// building yaml response
	server := Server{ApiKeys: keys, Name: &yaml.Node{Kind: yaml.ScalarNode, Value: random.String(5), LineComment: "rename server if another name is desired"}}
	config := Config{Server: server, Destinations: mappedDestinations}

	marshal, err := yaml.Marshal(&config)
	configYaml := yaml.Node{}

	if err = yaml.Unmarshal(marshal, &configYaml); err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to deserialize result configuration"})
		return
	}
	configYaml.HeadComment = configHeaderText

	c.Header("Content-Type", "application/yaml")
	encoder := yaml.NewEncoder(c.Writer)
	defer encoder.Close()

	encoder.SetIndent(2)
	err = encoder.Encode(&configYaml)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed write response"})
	}
}
